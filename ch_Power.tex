\chapter{Energy consumption}\label{ch:power}
When examining the performance of a computer program, its energy consumption must also be considered: not only to reduce the demand of non renewable resources but also to keep under control the amount of heat that must be dissipated from the devices executing the program.\\
The semiconductor manifacturing process has been constantly improving during the past 40 years bringing ever smaller transistors inside the processing units, which in turn allowed to have ever increasing performances without a substantial increase in energy consumption. For so long Moore's law stood the test: the number of transistors per chip kept doubling every two years or, equivalently, the transistors size in the chip halved every two years.
Unfortunately we are quickly approaching a probable stop of Moore's law: at the 5 $\unit{nm}$ scale -which will be probably reached in few years- the transistor size is of the same order of few radii of silicon atoms. At that scale the quantum tunneling effect also starts to play a role, making very unlikely that processing units based on the well known silicon technology will have smaller scale than 5 $\unit{nm}$.\\
For the above reasons it is very important, and it will be even more, that energy efficient computing is pursued through carefully designed software other than better hardware.\\
In the following sections we will present the measurement of the energy required to run the KD-tree algorithm described in the previous Chapter on different hardware setup.

\section{Measurement methodology}
The nearest neighbors search is the part of the algorithm contributing the most to the energy consumption. As a matter of fact we showed in the previous Chapter that it makes for almost the $90\%$ of the time execution of the entire algorithm, moreover we want to compare the energy used by the CPU sequential code, running slower but in principle using less power with respect to the more power intensive GPU that completes the task significantly faster.\\ 
The quantity we can actually measure are two: the time it takes to run the all nearest neighbors search and the the power used by the device performing the search at a given time.
Since the typical time for a complete search is of only few milliseconds, a single search would not be enough to measure accurately the power used in that small time window. For this reason we repeat the very same search several hundreds of times. The total time passed to perform all the repeations of the search is recorded and then divided by the number of repetitions of the search to have the average time of a single search. During those several repetitions the power used is sampled multiple times to evaluate its values and trend. In the case of the GPU parallel code we decided to exclude from the measurement the time needed to move to and from the GPU memory the data needed for the search. Indeed the memory movement uses a very low amount of energy while taking a relatively significant amount of time, thus it would change significantly the end result of the energy consumption measurement.\\
The run time of the search is measured through \code{cudaEvent}, as used for the performance analysis, while the power measurements is performed through dedicated software (when available) and hardware. The CPU sequential code power usage is evaluated through the use of the software \textit{turbostat} that is available for Intel processor, while the GPU code power usage is monitored by \textit{nvidia-smi} available for Nvidia GPU.\\
To complement all power measurements we also used a common appliance power meter that can be inserted between the wall electricity plug and the device to measure the power usage of.

\section{Benchmark machine}

\section{TK 1}

\section{Consumption comparisons}