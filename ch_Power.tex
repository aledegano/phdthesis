\chapter{Energy consumption}\label{ch:power}
When examining the performance of a computer program, its energy consumption is also a key factor: energy conservation must be taken into account in a world where most of the energy is produced through non renewable resources. Moreover the energy used by the device running the program translates in thermal energy that must be dissipated from the device, further increasing the total energy consumption and imposing severe limitations (e.g. volume occupancy) on the computing systems employing those devices.\\
The semiconductor manufacturing process has been constantly improving during the past 40 years bringing ever smaller transistors inside the processing units, which in turn allowed to have ever increasing performances without a substantial increase in energy consumption. For so long Moore's law stood the test: the number of transistors per chip kept doubling every two years or, equivalently, the transistors size in the chip halved every two years.
Unfortunately we are quickly approaching a probable stop of Moore's law: at the 5 $\unit{nm}$ scale -which will be probably reached in few years- the transistor size is of the same order of few radii of silicon atoms. At that scale the quantum tunneling effect also starts to play a role, making very unlikely that the transistors in the processing units, based on the well known silicon technology, will have smaller scale than 5 $\unit{nm}$. At that point any increase in computational power will require an inevitable electrical power increase for the device to operate.\\
For the above reasons it is very important, and it will be even more, that energy efficient computing is also pursued through carefully designed software other than better hardware.\\
In the following sections we will present the measurement of the energy required to run the KD-tree algorithm described in the previous Chapter on different hardware setups.

\section{Measurement methodology}
The nearest neighbors search is the part of the algorithm contributing the most to the energy consumption. As a matter of fact we showed in the previous Chapter that it makes for almost the $90\%$ of the time execution of the entire algorithm, moreover we want to compare the energy used by the CPU sequential code, running slower but in principle using less power with respect to the more power intensive GPU code that completes the task significantly faster.\\ 
The quantity we can actually measure are two: the time it takes to run the all nearest neighbors search and the the power used by the device performing the search at a given time.
Since the typical time for a complete search is of only few milliseconds, a single search would not be enough to measure accurately the power used in that small time window. For this reason we repeat the very same search several hundreds of times. The total time passed to perform all the reiterations of the search is recorded and then divided by the number of repetitions of the search to have the average time of a single search. During those several repetitions the power used is sampled multiple times to evaluate its values and trend. In the case of the GPU parallel code we decided to exclude from the measurement the time needed to move to and from the GPU memory the data needed for the search and its output. Indeed the memory movement uses a very low amount of energy while taking a relatively significant amount of time, thus it would change significantly the end result of the energy consumption measurement.\\
The run time of the search is measured through \code{cudaEvent}, as used for the performance analysis, while the power measurements is performed through dedicated software (when available) and hardware. The CPU sequential code power usage is evaluated through the use of the software \textit{turbostat} that is available for Intel processor, while the GPU code power usage is monitored by \textit{nvidia-smi} available for Nvidia GPU.\\
To complement all power measurements we also used a common appliance power meter that can be inserted between the wall electricity plug and the device to measure the power usage of the whole system.

\section{Benchmark machine}
Monitoring the power meter we evaluate the baseline power usage of the benchmark machine described in Section \ref{sec:benchmark}, that is the power used by the machine when is powered on, in an idle state and ready to run a program. Sampling the read of the power meter over a period of time yield an average baseline power of $60 \pm 1 \unit{W}$.
We build a KD-tree from $5 \times 10^5$ points generated in a volume with a random uniform distribution, we chose the highest amount of points used in the performance study to represent the worst possible scenario of operation.

\subsection{CPU energy consumption}
While running the all nearest neighbors search repeatedly as explained above we sample both the power meter power usage and \textit{turbostat} readings for the whole CPU package. The sampling of the power meter yields an average of $112 \pm 1 \unit{W}$ resulting in an effective increased power usage of $52 \pm 1 \unit{W}$ while the software \textit{turbostat} only reads $21 \pm 1 \unit{W}$: the two measures are clearly incompatible. We attribute this incompatibility to what the status software is actually monitoring, indeed it only reports the power usage of the CPU chip itself, while the power meter, measuring the whole system drainage, takes into account all the other PC components that may draw up more energy when performing the search than when they are idle (e.g. the power supply unit efficiency, the increase of RAM usage, etc...). Since we want to have the most reliable esteem and since we will consider the energy consumption of the whole GPU board when examining the parallel code, we decide to drop the measurement obtained with \textit{turbostat} in favor of the more conservative measurement of the power meter. The average time recorded to perform the all nearest neighbors search on the CPU with the sequential code is of $1.693 \pm 0.001 \unit{s}$. We want to express the resulting energy consumption in term of the amount of Joule necessary to perform a single all nearest neighbors search in a given tree, therefore simply multiplying the average power used by the average yields the result: $88 \pm 2 \unit{J/search}$.

\section{TK 1}

\section{Consumption comparisons}